/var/www/cyb3ria/.env

# ВАЖНО: Никогда не добавляйте этот файл в git!
# Формат: postgres://ПОЛЬЗОВАТЕЛЬ:ПАРОЛЬ@ХОСТ:ПОРТ/ИМЯ_БАЗЫ_ДАННЫХ
DATABASE_URL="postgres://cyb3ria:!Abs123@localhost:5432/cyb3ria"
JWT_SECRET="a-very-long-and-super-secret-string-for-jwt"



/var/www/cyb3ria/Cargo.toml

[package]
name = "cyb3ria"
version = "0.1.0"
edition = "2024"

[dependencies]
# Основные библиотеки
# ИЗМЕНЕНИЕ: Добавили фичу "ws" для WebSockets
axum = { version = "0.8.4", features = ["macros", "ws"] } 
tokio = { version = "1.47.0", features = ["full"] } 
futures = "0.3.30"
serde = { version = "1.0.203", features = ["derive"] } 
serde_json = "1.0.117"
log = "0.4"
env_logger = "0.9"
dotenvy = "0.15.7" 
sqlx = { version = "0.8.0", features = ["runtime-tokio-rustls", "postgres", "uuid", "chrono"] }
tracing = "0.1.41" 
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
# ИЗМЕНЕНИЕ: Добавили фичу "fs" для раздачи файлов
tower-http = { version = "0.5.2", features = ["trace", "cors", "fs"] } 
argon2 = "0.5"
uuid = { version = "1.9.1", features = ["serde", "v4"] }
jsonwebtoken = "9"
validator = { version = "0.16", features = ["derive"] }
time = "0.3"
chrono = { version = "0.4.38", features = ["serde"] }
rand = "0.8"
# НОВАЯ ЗАВИСИМОСТЬ для парсинга query string в WebSocket
querystring = "1.1.0"




/var/www/cyb3ria/src/main.rs

use std::net::SocketAddr;
use dotenvy::dotenv;
use std::env;
use tokio::net::TcpListener;
use axum::http::Method;

use tower_http::{
    cors::CorsLayer,
    trace::TraceLayer,
};

use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

mod db;
mod routes;
mod models;
mod handlers;
mod error;
mod state;
mod config;
mod auth;
mod ws;

use state::AppState;
use config::Config;
use ws::WsState;

#[tokio::main]
async fn main() {
    dotenv().ok();

    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "cyb3ria=debug,tower_http=debug".into()),
        )
        .with(tracing_subscriber::fmt::layer())
        .init();

    let config = Config::from_env();
    let database_url = env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let pool = db::connect_db(&database_url).await;
    
    // ИЗМЕНЕНИЕ: Создаем единое состояние приложения
    let app_state = AppState { 
        pool,
        config,
        ws_state: WsState::new(), // Инициализируем WsState здесь
     };

    let cors = CorsLayer::new()
        .allow_origin([
            "https://cyb3ria.xyz".parse().unwrap(),
            "http://localhost:3000".parse().unwrap(),
            "http://192.168.1.45:3000".parse().unwrap(),
        ])
        .allow_headers([
            axum::http::header::AUTHORIZATION,
            axum::http::header::CONTENT_TYPE
        ])
        .allow_methods([Method::GET, Method::POST, Method::PATCH, Method::DELETE]);

    // ИЗМЕНЕНИЕ: Создаем роутер с единым состоянием
    let app = routes::create_routes(app_state)
        .layer(TraceLayer::new_for_http())
        .layer(cors);

    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));
    tracing::debug!("Listening on {}", addr);
    let listener = TcpListener::bind(&addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}



/var/www/cyb3ria/src/db.rs

use sqlx::postgres::PgPoolOptions;
use sqlx::PgPool;

pub async fn connect_db(database_url: &str) -> PgPool {
    PgPoolOptions::new()
        .max_connections(5)
        .connect(database_url)
        .await
        .expect("Не удалось подключиться к базе данных")
}




/var/www/cyb3ria/src/error.rs

use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
    Json,
};
use serde_json::json;

// Наш кастомный тип ошибки.
#[derive(Debug)]
pub enum AppError {
    SqlxError(sqlx::Error),
    // НОВЫЙ ВАРИАНТ для ошибок хэширования
    PasswordHashError(argon2::password_hash::Error),
    NotFound,
    Unauthorized,
    InvalidCredentials, // <- ошибка для неудачного входа
    InternalServerError, // <- общая ошибка 500
     
}

// Реализация преобразования ошибки в HTTP-ответ.
impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_message) = match self {
            AppError::SqlxError(e) => {
                tracing::error!("SQLx error: {:?}", e);
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    "Internal Server Error".to_string(),
                )
            }
            // НОВЫЙ БЛОК для обработки ошибки хэширования
            AppError::PasswordHashError(e) => {
                tracing::error!("Password hashing error: {:?}", e);
                (
                    StatusCode::INTERNAL_SERVER_ERROR,
                    "Internal Server Error".to_string(),
                )
            }
            AppError::InvalidCredentials => {
                (StatusCode::UNAUTHORIZED, "Invalid email or password".to_string())
            }
            AppError::InternalServerError => {
                (StatusCode::INTERNAL_SERVER_ERROR, "An internal error occurred".to_string())
            }
            AppError::Unauthorized => {
                (StatusCode::UNAUTHORIZED, "Authentication required".to_string())
            }
            AppError::NotFound => (StatusCode::NOT_FOUND, "Resource not found".to_string()),

        };

        let body = Json(json!({ "error": error_message }));
        (status, body).into_response()
    }
}

// Позволяет использовать `?` для `sqlx::Error`.
impl From<sqlx::Error> for AppError {
    fn from(err: sqlx::Error) -> Self {
        match err {
            sqlx::Error::RowNotFound => AppError::NotFound,
            _ => AppError::SqlxError(err),
        }
    }
}

// НОВАЯ РЕАЛИЗАЦИЯ: Позволяет использовать `?` для `argon2::password_hash::Error`.
impl From<argon2::password_hash::Error> for AppError {
    fn from(err: argon2::password_hash::Error) -> Self {
        AppError::PasswordHashError(err)
    }
}



/var/www/cyb3ria/src/state.rs

use sqlx::PgPool;
use crate::config::Config;
use crate::ws::WsState; // Импортируем состояние WebSocket

// ИЗМЕНЕНИЕ: Создаем единую структуру состояния для всего приложения.
// `#[derive(FromRef)]` позволяет хендлерам извлекать части состояния,
// например `State<Config>` или `State<WsState>`, из общего `State<AppState>`.
#[derive(Clone, axum::extract::FromRef)]
pub struct AppState {
    pub pool: PgPool,
    pub config: Config,
    pub ws_state: WsState, // Включаем состояние WebSocket сюда
}



/var/www/cyb3ria/src/config.rs

// /var/www/cyb3ria/src/config.rs
use std::env;

#[derive(Clone)]
pub struct Config {
    pub jwt_secret: String,
}

impl Config {
    pub fn from_env() -> Self {
        Self {
            jwt_secret: env::var("JWT_SECRET").expect("JWT_SECRET must be set"),
        }
    }
}



/var/www/cyb3ria/src/auth.rs

// /var/www/cyb3ria/src/auth.rs

use axum::{
    body::Body,
    http::{Request},
    middleware::Next,
    response::Response,
    extract::State,
};
use jsonwebtoken::{decode, DecodingKey, Validation};
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use crate::{state::AppState, error::AppError};

// Claims остаются публичными, так как используются и в user_handler
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: Uuid,
    pub username: String,
    pub exp: i64,
    pub pk: String, // <-- НОВОЕ ПОЛЕ: Public Key в base64
}

pub async fn auth_middleware(
    State(state): State<AppState>,
    mut request: Request<Body>,
    next: Next,
) -> Result<Response, AppError> {
    let token = request.headers()
        .get("Authorization")
        .and_then(|auth_header| auth_header.to_str().ok())
        .and_then(|auth_value| auth_value.strip_prefix("Bearer "))
        .ok_or(AppError::Unauthorized)?;

    let claims = decode::<Claims>(
        token,
        &DecodingKey::from_secret(state.config.jwt_secret.as_ref()),
        &Validation::default(),
    )
    .map_err(|_| AppError::Unauthorized)?
    .claims;

    request.extensions_mut().insert(claims.sub);

    Ok(next.run(request).await)
}



/var/www/cyb3ria/src/routes/mod.rs

use axum::{Router, middleware, routing::get}; // <-- Добавили get
use crate::state::AppState;
use crate::auth::auth_middleware;
use tower_http::services::ServeDir;
use crate::ws; // <-- Импортируем ws модуль

mod users;
mod messages;
mod discussions;
mod comments;

pub fn create_routes(app_state: AppState) -> Router {
     // 1. Защищенные роуты (БЕЗ WebSocket)
    let protected_routes = Router::new()
        .merge(users::create_protected_user_routes())
        .merge(messages::create_message_routes())
        .merge(discussions::create_discussion_routes())
        .merge(comments::create_comment_routes())
        .layer(middleware::from_fn_with_state(app_state.clone(), auth_middleware));

    // 2. Публичные роуты
    let public_routes = Router::new()
        .merge(users::create_public_user_routes());

    // 3. Собираем API-роутер. WebSocket-роут добавляется отдельно,
    //    так как у него своя логика аутентификации (через query-параметр).
    let api_router = Router::new()
        .merge(public_routes)
        .merge(protected_routes)
        .route("/ws", get(ws::ws_handler)); // <-- ВОТ КЛЮЧЕВОЕ ИЗМЕНЕНИЕ
    Router::new()
        .nest("/api", api_router)
        .fallback_service(ServeDir::new("public"))
        .with_state(app_state) // <-- Передаем единое состояние один раз в самом конце
}



/var/www/cyb3ria/src/routes/users.rs

// /var/www/cyb3ria/src/routes/users.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::user_handler;

// --- ВОТ ЭТА ФУНКЦИЯ ПРОПАЛА ---
// Роуты, не требующие аутентификации (регистрация и вход)
pub fn create_public_user_routes() -> Router<AppState> {
    Router::new()
        .route("/users", post(user_handler::create_user))
        .route("/login", post(user_handler::login))
}
// --- КОНЕЦ ВОССТАНОВЛЕННОГО БЛОКА ---

// Роуты, требующие аутентификации (получение инфо о юзере и списка всех юзеров)
pub fn create_protected_user_routes() -> Router<AppState> {
    Router::new()
        .route("/users", get(user_handler::get_all_users)) // <- Получение списка
        .route("/users/{id}", get(user_handler::get_user))   // <- Получение одного по ID
}



/var/www/cyb3ria/src/routes/messages.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::message_handler; // <- Указываем на новый хендлер

pub fn create_message_routes() -> Router<AppState> {
    Router::new()
        .route("/messages", post(message_handler::create_message))
        .route("/messages/{partner_id}", get(message_handler::get_conversation_with))
}



/var/www/cyb3ria/src/routes/discussions.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::discussion_handler; // <- Указываем на новый хендлер

pub fn create_discussion_routes() -> Router<AppState> {
    Router::new()
        .route("/discussions", post(discussion_handler::create_discussion))
        .route("/discussions/{id}", get(discussion_handler::get_discussion))
}



/var/www/cyb3ria/src/routes/comments.rs

use axum::{Router, routing::{get, post}};
use crate::state::AppState;
use crate::handlers::comment_handler; // <- Указываем на новый хендлер

pub fn create_comment_routes() -> Router<AppState> {
    Router::new()
        .route("/comments", post(comment_handler::create_comment))
        .route("/comments/{id}", get(comment_handler::get_comment))
}



/var/www/cyb3ria/src/handlers/mod.rs

pub mod user_handler;
pub mod message_handler;
pub mod discussion_handler;
pub mod comment_handler;



/var/www/cyb3ria/src/handlers/user_handler.rs

use axum::{
    extract::{Path, State},
    Json,
};
use uuid::Uuid;
use argon2::{
    password_hash::{
        rand_core::OsRng,
        PasswordVerifier,
        PasswordHasher, 
        SaltString
    },
    Argon2
};
use jsonwebtoken::{encode, EncodingKey, Header};
use chrono::{Utc, Duration};
use serde::{Serialize, Deserialize}; 
use crate::auth::Claims; 
use crate::{
    state::AppState,
    models::user::User,
    error::AppError,
};

#[derive(Serialize, sqlx::FromRow)]
pub struct SafeUser {
    pub id: Uuid,
    pub username: String,
    pub public_key: Option<String>,
}

pub async fn get_all_users(
    State(state): State<AppState>,
) -> Result<Json<Vec<SafeUser>>, AppError> {
    let users = sqlx::query_as::<_, SafeUser>(
        "SELECT id, username, public_key FROM users"
    )
    .fetch_all(&state.pool)
    .await?;
    Ok(Json(users))
}

// ИЗМЕНЕНИЕ: Добавлено поле для зашифрованного ключа
#[derive(Deserialize)]
pub struct CreateUserPayload {
    pub username: String,
    pub email: String,
    pub password: String,
    pub public_key: String,
    pub encrypted_private_key: String,
}

pub async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserPayload>,
) -> Result<Json<User>, AppError> {
    let password_hash = tokio::task::spawn_blocking(move || {
        let salt = SaltString::generate(&mut OsRng);
        Argon2::default()
            .hash_password(payload.password.as_bytes(), &salt)
            .map(|hash| hash.to_string())
    })
    .await.map_err(|_| AppError::InternalServerError)??;
    
    // ИЗМЕНЕНИЕ: Добавляем encrypted_private_key в запрос
    let new_user_id = sqlx::query!(
        "INSERT INTO users (username, email, password_hash, public_key, encrypted_private_key) VALUES ($1, $2, $3, $4, $5) RETURNING id",
        payload.username,
        payload.email,
        password_hash,
        payload.public_key,
        payload.encrypted_private_key
    )
    .fetch_one(&state.pool)
    .await?
    .id;

    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE id = $1",
        new_user_id
    )
    .fetch_one(&state.pool)
    .await?;
    Ok(Json(user))
}

pub async fn get_user(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<User>, AppError> {
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;
    Ok(Json(user))
}

#[derive(Deserialize)]
pub struct LoginPayload {
    pub email: String,
    pub password: String,
}

// ИЗМЕНЕНИЕ: Структура ответа теперь содержит и зашифрованный ключ
#[derive(Serialize)]
pub struct AuthResponse {
    token: String,
    encrypted_private_key: Option<String>,
}

pub async fn login(
    State(state): State<AppState>,
    Json(payload): Json<LoginPayload>,
) -> Result<Json<AuthResponse>, AppError> {
    let user = sqlx::query_as!(
        User,
        "SELECT * FROM users WHERE email = $1",
        payload.email
    )
    .fetch_optional(&state.pool)
    .await?
    .ok_or(AppError::InvalidCredentials)?;

    let password_hash_str = user.password_hash.clone().ok_or(AppError::InvalidCredentials)?;
    let password = payload.password.clone();
    let verification_result = tokio::task::spawn_blocking(move || {
        let parsed_hash = argon2::PasswordHash::new(&password_hash_str)?;
        Argon2::default().verify_password(password.as_bytes(), &parsed_hash)
    }).await.map_err(|_| AppError::InternalServerError)?;

    if verification_result.is_ok() {
        let now = Utc::now();
        let exp = (now + Duration::days(1)).timestamp();
        
        let claims = Claims {
            sub: user.id,
            username: user.username.clone(),
            exp,
            pk: user.public_key.clone().unwrap_or_default(),
        };

        let token = encode(
            &Header::default(), &claims,
            &EncodingKey::from_secret(state.config.jwt_secret.as_ref()),
        ).map_err(|_| AppError::InternalServerError)?;

        // ИЗМЕНЕНИЕ: Возвращаем токен и зашифрованный ключ
        Ok(Json(AuthResponse { 
            token,
            encrypted_private_key: user.encrypted_private_key,
        }))
    } else {
        Err(AppError::InvalidCredentials)
    }
}



/var/www/cyb3ria/src/handlers/message_handler.rs

use axum::{
    extract::{Path, State, Json},
    Extension,
};
use uuid::Uuid;
use crate::{
    state::AppState, // <-- ИЗМЕНЕНИЕ: Используем единый AppState
    models::message::Message,
    error::AppError,
};

#[derive(serde::Deserialize)]
pub struct CreateMessagePayload {
    pub recipient_id: Uuid,
    pub content: String,
}

// ИЗМЕНЕНИЕ: Убираем второй State, теперь все в одном AppState
pub async fn create_message(
    Extension(user_id): Extension<Uuid>,
    State(state): State<AppState>,
    Json(payload): Json<CreateMessagePayload>,
) -> Result<Json<Message>, AppError> {
    if user_id == payload.recipient_id {
        return Err(AppError::InternalServerError); 
    }

    let message = sqlx::query_as!(
        Message,
        "INSERT INTO messages (user_id, recipient_id, content) VALUES ($1, $2, $3) RETURNING *",
        user_id,
        payload.recipient_id,
        payload.content
    )
    .fetch_one(&state.pool)
    .await?;

    // ИЗМЕНЕНИЕ: Обращаемся к ws_state через общее состояние state
    if let Err(e) = state.ws_state.tx.send((message.clone(), user_id)) {
        tracing::error!("Failed to broadcast message: {}", e);
    }
    
    Ok(Json(message))
}

pub async fn get_conversation_with(
    Extension(user_id): Extension<Uuid>,
    State(state): State<AppState>,
    Path(partner_id): Path<Uuid>,
) -> Result<Json<Vec<Message>>, AppError> {
    let messages = sqlx::query_as!(
        Message,
        "SELECT * FROM messages 
         WHERE (user_id = $1 AND recipient_id = $2) OR (user_id = $2 AND recipient_id = $1)
         ORDER BY created_at ASC",
        user_id,
        partner_id
    )
    .fetch_all(&state.pool)
    .await?;
    Ok(Json(messages))
}



/var/www/cyb3ria/src/handlers/discussion_handler.rs

use axum::{
    extract::{Path, State},
    Json, 
};
use axum::Extension;

use uuid::Uuid;
use crate::{
    state::AppState,
    models::discussion::Discussion,
    error::AppError,
};


#[derive(serde::Deserialize)]
pub struct CreateDiscussionPayload {
    pub title: String,
}

pub async fn create_discussion(
    Extension(user_id): Extension<Uuid>, // <-- Получаем ID автора из токена
    State(state): State<AppState>,
    Json(payload): Json<CreateDiscussionPayload>,
) -> Result<Json<Discussion>, AppError> {
    let discussion = sqlx::query_as!(
        Discussion,
        "INSERT INTO discussions (title, author_id) VALUES ($1, $2) RETURNING *",
        payload.title,
        user_id // <-- Используем проверенный ID
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(discussion))
}

pub async fn get_discussion(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<Discussion>, AppError> {
    let discussion = sqlx::query_as!(
        Discussion,
        "SELECT * FROM discussions WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(discussion))
}



/var/www/cyb3ria/src/handlers/comment_handler.rs

use axum::{
    extract::{Path, State},
    Json,
};
use uuid::Uuid;
use crate::{
    state::AppState,
    models::comment::Comment,
    error::AppError,
};
use axum::Extension;

#[derive(serde::Deserialize)]
pub struct CreateCommentPayload {
    pub discussion_id: Uuid,
    pub content: String,
}

pub async fn create_comment(
    Extension(user_id): Extension<Uuid>, // <-- ПОЛУЧАЕМ ID автора из токена
    State(state): State<AppState>,
    Json(payload): Json<CreateCommentPayload>,
) -> Result<Json<Comment>, AppError> {
    let comment = sqlx::query_as!(
        Comment,
        "INSERT INTO comments (discussion_id, author_id, content) VALUES ($1, $2, $3) RETURNING *",
        payload.discussion_id,
        user_id, // <-- ИСПОЛЬЗУЕМ безопасный ID из токена
        payload.content
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(comment))
}

pub async fn get_comment(
    State(state): State<AppState>,
    Path(id): Path<Uuid>,
) -> Result<Json<Comment>, AppError> {
    let comment = sqlx::query_as!(
        Comment,
        "SELECT * FROM comments WHERE id = $1",
        id
    )
    .fetch_one(&state.pool)
    .await?;

    Ok(Json(comment))
}



/var/www/cyb3ria/src/models/mod.rs

pub mod user;
pub mod message;
pub mod discussion;
pub mod comment;




/var/www/cyb3ria/src/models/user.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct User {
    pub id: Uuid,
    pub username: String,
    pub email: String,
    pub public_key: Option<String>,

    // НОВОЕ ПОЛЕ для зашифрованного ключа
    #[serde(skip_serializing)] // Не отправляем его в JSON по умолчанию
    pub encrypted_private_key: Option<String>,

    #[serde(skip_serializing)]
    pub password_hash: Option<String>,

    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}



/var/www/cyb3ria/src/models/message.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

// ИЗМЕНЕНИЕ: Добавили Clone, чтобы сообщения можно было рассылать через broadcast
#[derive(Debug, Serialize, Deserialize, sqlx::FromRow, Clone)]
pub struct Message {
    pub id: Uuid,
    pub user_id: Uuid,
    pub recipient_id: Option<Uuid>,
    pub content: String,
    pub created_at: DateTime<Utc>,
}



/var/www/cyb3ria/src/models/discussion.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Discussion {
    pub id: Uuid,
    pub title: String,
    pub author_id: Uuid, // <- Добавлено это поле
    pub created_at: DateTime<Utc>,
}



/var/www/cyb3ria/src/models/comment.rs

use serde::{Serialize, Deserialize};
use uuid::Uuid;
use chrono::{DateTime, Utc};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Comment {
    pub id: Uuid,
    pub discussion_id: Uuid,
    pub author_id: Uuid, // <- Переименовано с user_id на author_id
    pub content: String,
    pub created_at: DateTime<Utc>,
}



/var/www/cyb3ria/static/index.html

<!-- /var/www/cyb3ria/static/index.html -->
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyb3ria Project</title>
    
    <!-- Вот самая важная строка для иконки! -->
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    
    <!-- Подключаем стили, если нужно -->
    <link rel="stylesheet" href="/static/statix.css">
</head>
<body>
    <div class="container">
        <h1>Сайт работает!</h1>
        <p>Эта страница (index.html) и иконка были успешно отданы Rust-бэкендом через Nginx.</p>
    </div>
</body>
</html>



/var/www/cyb3ria/static/statix.css

/* Простой тестовый CSS */
body {
    font-family: Arial, sans-serif;
    background-color: #f0f0f0;
    color: #333;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}



/var/www/cyb3ria/migrations/20250810000001_create_users_table.sql

-- Add migration script here

-- Создаем расширение, если оно еще не установлено, для использования UUID
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Создаем таблицу пользователей
CREATE TABLE users (
-- Уникальный идентификатор пользователя, генерируется автоматически
id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

-- Имя пользователя, должно быть уникальным и непустым
username VARCHAR(255) UNIQUE NOT NULL,

-- Хеш пароля. Никогда не храните пароли в открытом виде!
-- Поле может быть NULL, так как у нас будет аутентификация без пароля (passkeys).
password_hash VARCHAR(255),

-- Email, должен быть уникальным.
email VARCHAR(255) UNIQUE NOT NULL,

-- Временные метки
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Добавляем триггер для автоматического обновления поля updated_at
-- при любом изменении строки. Это очень удобно.
CREATE OR REPLACE FUNCTION trigger_set_timestamp()
RETURNS TRIGGER AS $$
BEGIN
NEW.updated_at = NOW();
RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_timestamp
BEFORE UPDATE ON users
FOR EACH ROW
EXECUTE FUNCTION trigger_set_timestamp();



/var/www/cyb3ria/migrations/20250810000002_create_messages.sql

CREATE TABLE messages (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);



/var/www/cyb3ria/migrations/20250810000003_create_discussions.sql

CREATE TABLE discussions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title TEXT NOT NULL,
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);




/var/www/cyb3ria/migrations/20250810000004_create_comments.sql

CREATE TABLE comments (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    discussion_id UUID NOT NULL REFERENCES discussions(id) ON DELETE CASCADE,
    author_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);




/var/www/cyb3ria/migrations/20250810000005_add_public_key_to_users.sql

-- Add up migration script here
ALTER TABLE users ADD COLUMN public_key TEXT;

-- Add down migration script here
 ALTER TABLE users DROP COLUMN public_key;



/var/www/cyb3ria/migrations/20250810000006_add_recipient_to_messages.sql

-- Add up migration script here
-- Добавляем колонку для ID получателя
ALTER TABLE messages ADD COLUMN recipient_id UUID;

-- Создаем связь с таблицей users, чтобы нельзя было отправить сообщение несуществующему пользователю
ALTER TABLE messages ADD CONSTRAINT fk_recipient
    FOREIGN KEY (recipient_id) REFERENCES users(id) ON DELETE SET NULL;

-- 'Down' миграция для отката
-- Add down migration script here
ALTER TABLE messages DROP CONSTRAINT fk_recipient;
ALTER TABLE messages DROP COLUMN recipient_id;



